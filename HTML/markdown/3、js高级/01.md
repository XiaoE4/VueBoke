# JavaScript高级

# ajax

## 1.认识

```javascript
//1. 创建XHR
let xhr = new XMLHttpRequest( )
console.log(xhr)

// 2.配置open，规定请求（请求方式，请求地址，同步和异步(true&false)）
// localhost 本机域名 127.0.0.1 本机ip (live server)
// 请求方式：GET和POST：
/*
与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。
然而，在以下情况中，请使用 POST 请求：
    1. 不愿使用缓存文件（更新服务器上的文件或数据库）
    2. 向服务器发送大量数据（POST 没有数据量限制）
    3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
*/
xhr.open("GET","输入请求的地址",true&false)
//true表示异步
//false表示同步

//3. send	将请求发送到服务器
xhr.send()

// 4.接收数据，注册一个事件
xhr.onreadystatechange= fn1=>{
    console.;og("xhr.readyState")
    if(xhr.readyState === 4 && xhr.status=== 200){
        console.log("解析完成",xhr.responseText)
    }  else if(xhr.readyState ===4 && xhr.status ===404){
		console.log("没有找到")
        //location.href="404.html"
    }
}
xhr.onload =fn2=>{
	console.log("onload",xhr.readyState)	
    if(xhr.status===200){
                console.log(JSON.parse(xhr.responseText));
            }else if (xhr.status===404){
                console.error("not found")
            }
}
```



## 2.请求方式（json-server）

form get post

#### 1.get 偏向获取数据

```javascript
xhr.open("GET","http://localhost:3000/users")
// xhr.open("GET","http://localhost:3000/users?username=xiaoE")添加?username=xiaoE为定点查找所有username为xiaoE的，或者输全表单内容进行查找匹配?username=xiaoE&password=123
if(xhr.status===200){
    //if（^2\d{2|$/.test(xhr.status)）{ }
    ///^2\d{2|$/.test(xhr.status)	status=200-299均为正确，这样写可以判断是否在这个范围内
    console.log(JSON.parse(xhr.responseText));
}
```

#### 2.post 偏向提交数据

```javascript
xhr.open("POST","http://localhost:3000/users")

            xhr.onload = function(){
                if(/^2\d{2|$/.test(xhr.status)){
                    console.log(JSON.parse(xhr.responseText));
                }
                //提交信息
                // 第一种：post name=xiaoE&age=20
                xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded")
                xhr.send(`username=xiaoB&password=123`)
                // 第二种：post{"name":"xiaoE","age":20}
                xhr.setRequestHeader("Content-Type","application/json")
                xhr.send(JSON.stringify({
                    username:"xiaoE",
                    password:"987"
            }))
```



#### 3.put 偏向更新（覆盖修改）

```javascript
xhr.open("PUT","http://localhost:3000/users/1")	//user/id
//其余和post一样，更新为覆盖更新，如原有name和age，更新只写了name，则age也被覆盖消失，数据内只剩下name
```



#### 4.delete 偏向删除信息

```javascript
xhr.open("DELETE","http://localhost:3000/users/1")//user/id
	xhr.setRequestHeader("Content-Type","application/json")
        xhr.send()
```



#### 5.patch	偏向部分修改（不覆盖）

```javascript
xhr.open("PATCH","http://localhost:3000/users/1")//user/id
xhr.setRequestHeader("Content-Type","application/json")
            xhr.send(JSON.stringify({
                username:"xiaoE123",
            }))
//修改后原有的其他内容依然存在，不进行覆盖
```

open里面第一个词为使用的功能（get、post、put、delete、patch）

  - header
  - option
  - connect


## 3.nodejs的使用和问题

`npm install json-server -g`		//终端下载json-server

`json-server` -基于一个json文件就可以创建很多的后端模拟接口

问题：系统禁止运行脚本，npm fund，清除缓存。

正常使用：右键终端运行，输入`json-server .\test1.json --watch` 	//数据为test1.json

- 端口占用：

  输入：`netstat -ano` 查看端口

  在cmd 输入 `taskkill /f /t /im` 对应的 TCP 号（最后面的一串数字），来关掉被占用的端口，之后再次运行使用。

## 4.封装

url：传输地址

method：请求方式（GET,POST···）

async：是否异步

data：数据

headers：{

```javascript
// "Content-Type":"application/x-www-form-urlencoded"
"content-type":"application/json"
```

}

success：成功回调函数

error：失败回调函数

![66607799509](C:\Users\小饿\AppData\Local\Temp\1666077995096.png)

#  Promise

解决回调地狱的一种方法

##  1.基础语法

`resolve`和`reject`

`q.then(fn(  ){	}).catch(fn(  ){  })`

```javascript
// Promise构造函数
//承诺对象 q
var q=new Promise(function(resolve,reject){
                  setTimeout(()=>{
                  //成功兑现承诺
                  resolve(["111","222","333"])
		 //失败拒绝承诺
		 reject("err0r")
                  },2000)
                  })
                  // pending 执行中
                  //fulfilled 成功
                  //reject 拒绝
                  
                  //q就是Promise对象
                  q.then(function(res){
                      // 兑现承诺，这个函数被执行
                      console.log("success",res)
                  }).catch(function(err){
                      // 拒绝承诺，这个函数就会被执行
                      console.log("fail",err)
                  })
```

## 2.封装ajax

then后面紧跟着then，执行时为链式依次执行，then后的pajax在前面加上return返回，最后加上catch，如果then出错则直接跳到catch。
相比于在success内嵌套ajax更加简洁，便于查看，解决回调地狱。

```javascript
pajax({
            url: "http://localhost:3000/news",
            data: {
                author: "kerwin"
            }
        }).then(res => {
            // console.log("success",res);
            return pajax({
                url: "http://localhost:3000/comments",
                data: {
                    newsId: res[0].id
                }
            })
            }).then(res => {
                console.log("success",res);
        }).catch(err=>{
            console.log("fail",err);
        })

```



## 3.promise.all

`primise.all`：并发处理

```javascript
console.log("正在加载")
let q1 =pajax({
    url:"http://localhost:3000/looplist"
})
let q2=pajax({
    url:"http://localhost:3000/datalist"
})

Promise.all([q1,q2]).then(res=>{
    console.log(res)
    console.log("隐藏加载")
}).catch(err=>{
    console.log(err)
})
// q1和q2并发处理，处理完再进行log打印，如果一个错误则catch错误。
```

# async和await

## 1.使用方法

- `async/await` 是一个 es7 的语法


- 这个语法是 **回调地狱的终极解决方案**
- 语法：

```javascript
 async function fn( ) {
    const res = await promise对象
  }
```

适用于链式调用，可以简化代码

- 这个是一个特殊的函数方式
- 可以 await 一个 promise 对象
- **可以把异步代码写的看起来像同步代码**
- 只要是一个 promiser 对象，那么我们就可以使用 `async/await` 来书写

```javascript
async function test() {
            // await同步代码/ promise对象
            var res = await pajax({
                url:"http://localhost:3000/news",
                data:{
                    author:"kerwin"
                }
            })
            // console.log(res);
            var res2 =pajax({
                url: "http://localhost:3000/comments",
                data: {
                    newsId: res[0].id
                }
            })

            return res2
        }

        test().then(res=>{
            console.log("返回结果：",res);
        }).catch(err=>{
            console.log(err);
        })

        test()
```



##  2. async函数里怎么捕获错误

利用`try，catch`捕获错误

```javascript
try{
    var res1 = await pajax({
        url:"http://localhost:3000/news"
        data:{
        	author:"kerwin"
    	}
    })
    var res2 = await pajax({
	url:"http://localhost:3000/comments"
        data:{
        	newsId:res[0].id
    	}
    })
    console.log("success",res1) 
}catch(err){
    console.log(err)
}
```

# fetch

**XMLHttpRequest** *是一个设计粗糙的 API，配置和调用方式非常混乱， 而且基于事件的异步模型写起来不友好。* 

```javascript
// 读取和判断
let username="xiaoE"
fetch(`http://localhost:3000/user?username=${username}`).then(res=>{
    console.log(res)
    // 把数据按照json类型读出来
    if(res.ok){
        return res.json()
    }else{
        // 拒绝
        return Promise.reject({
            a:1,
            status:res.status,
            statusText:res.statusText
        })
    }
    // 默认执行完这个then后直接执行下一个then，无论这个then是否错误
}).then(res=>{
    console.log("success",res)
}).catch(err=>{
    console.log("error",err)
})			// 默认不会走catch，所以要对res加以判断进行拒绝承诺。这样才会走catch返回err
```

↓	在fetch内添加其他内容，需要在括号内的url外加逗号和大括号进行添加，之后添加输出`res.json( )`

```javascript
// 在fetch内添加其他内容
fetch("http://localhost:3000/users/2",{
    method:"PUT",
    headers:{
	"content-type":"application/json"
    },
    body:JSON.stringify({
	username:"xigema"
    })
}).then(res=>res.json())
    .then(res=>{
    	console.log(res)
})

// fetch("http://localhost:3000/looplist").then(res=>res.json())
```

## json-server接口分析:

![66616262173](C:\Users\小饿\AppData\Local\Temp\1666162621733.png)

page=1：第一页，limit=3：每页3个数据（id为1、2、3的数据）

# cookie

## 特点

1. 只能存储文本
2. 单条存储有大小限制4KB左右

   数量限制（一般浏览器，限制大概在50条左右）

3. 读取有域名限制：不可跨域读取，只能由来自 写入cookie的 同一域名 的网页可进行读取。简单的讲就是，哪个服务器发给你的cookie，只有哪个服务器有权利读取
4. 时效限制：每个cookie都有时效，默认的有效期是，会话级别：就是当浏览器关闭，那么cookie立即销毁，但是我们也可以在存储的时候手动设置cookie的过期时间
5. 路径限制：存cookie时候可以指定路径，只允许子路径读取外层cookie，外层不能读取内层。

## 代码
```javascript
	// http协议无状态
        // localStorage：用户名和密码？     token 钥匙 ==> Nodejs token认证
        // cookie 本地存储  sessionID 钥匙 ===>Nodejs cookie+session认证
        // 存cookie

        savebtn.onclick = function () {
            // cookie: key=value
            // 路径设置
            // document.cookie="username=xiaoE;path=/05-cookie/01.html"
            document.cookie = "age=18"

            // 过期时间设置
            var date = new Date()
            date.setMinutes(date.getMinutes() + 10)
            document.cookie = `username=xiaoE;expires=${date.toUTCString()}`
            // 设置中国时间，不加 .toUTCString()  的话使用的时间为美国时间
        }
        // 获取cookie
        getbtn.onclick = function () {
            // console.log(document.cookie);
            console.log(getCookie("username"))
            // 获取key为username的value
        }

        function getCookie(key) {
            let str = document.cookie		// 获取cookie的全部数据
            let arr = str.split("; ")			// ；分割获取
            //console.log(str);
            //console.log(arr);
            var obj = {}
            for (let i = 0; i < arr.length; i++) {
                let subArr = arr[i].split("=")
                // console.log(subArr);
                obj[subArr[0]] = subArr[1]
            }
            // console.log(obj);
            return obj[key]
        }

        delbtn.onclick = function () {
            var date = new Date()
            date.setMinutes(date.getMinutes() - 1)
            document.cookie = `username=xiaoE;expires=${date.toUTCString()}`
            document.cookie = `age=114514;expires=${date.toUTCString()}`
        }
```

# jsonp

Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

为什么我们从不同的域（网站）访问数据需要一个特殊的技术( JSONP )呢？这是因为同源策略。

```javascript
const script = document.createElement('script')

script.src = './kerwin.txt'

document.body.appendChild(script)

```

# 闭包

函数内部返回一个函数，被外界所引用。

这个内部函数就不会被销毁回收

内部函数所用到的外部函数的变量也不会被销毁。

优点：让临时变量永驻内存

```javascript

```




# 问题
## 1、Web Server插件更改目录
扩展设置内：
Preview Server: Startup Project
Name of startup project. This setting is meaningful only when in the workspace.

![66618000274](C:\Users\小饿\AppData\Local\Temp\1666180002744.png)

填写需要用的项目名，在更改后进入show UI Page (ctrl+shift+u)进行查看

Serving files from![66617998195](C:\Users\小饿\AppData\Local\Temp\1666179981950.png)

![66618326213](C:\Users\小饿\AppData\Local\Temp\1666183262131.png)

Consolas, 'Microsoft Yahei', monospace

# js案例
##  141：音乐播放器

- 目录

![66625751841](C:\Users\小饿\AppData\Local\Temp\1666257518414.png)

- 效果

![66625758673](C:\Users\小饿\AppData\Local\Temp\1666257586732.png)